# 代码规范

## 2. 编码规范正文

### 2.1 格式

#### 2.1.1 大括号换不换行？随意。

可以使用

```cpp
class A {

};

for (auto element : array) {
    
}
```

也可以使用

```cpp
class A 
{

};

for (auto element : array)
{
    
}
```

**但不能使用：**

```cpp
class A{

};

for (auto element : array){
    
}
```

#### 2.1.2 哪里应该使用空格
1. 在使用赋值运算符、关系运算符、逻辑运算符、位运算符、算术运算符等二元操作符时，在其两边各加一个空格。  
    例：`nCount = 2;` 而不是 `nCount=2;`
2. 三目运算符的 `?` 和 `:` 前后均各加 1 个空格。
3. 函数的各参数间、数组初始化列表的各个初始值间，要用 `,` 和后续一个空格隔开。  
    例：`void GetDate(int x, int y);`  
    而不是 `void GetDate(int x,int y);` 或 `void GetDate(int x ,int y);`
4. 控制语句 `if, for, while, switch` 和之后的 `(` 之间加一个空格。
5. 控制语句 `if, for, while, switch` 之后的 `)` 与 `{` 之间加一个空格（同行的情况下）。
6. 控制语句 `do` 和之后 `{` 之间加一个空格（同行的情况下）。
7. `case` 的常数表达式之后、`default` 之后的 `:` 前面，要有一个空格。

#### 2.1.3 哪里不应该使用空格
1. 不要在引用操作符前后使用空格。引用操作符指 `.` 和 `->`，以及 `[]`。
2. 不要在 `::` 前后使用空格。
3. 不要在一元操作符和其操作对象之间使用空格，一元操作符包括 `++`、`--`、`!`、`&`、`*` 等。
4. `;` 前不能有空格。

举例：
```cpp
// 不要像下面这样写代码
m_pFont -> Font;

// 应该写成这样
m_pFont->Font;
```

#### 2.1.4 缩进
对程序语句要按其逻辑进行水平缩进，以4个空格为一个缩进单位，使同一逻辑层次上的代码在列上对齐。

#### 2.1.5 长语句的书写格式
描述：
较长的语句（长度大于80字符，包含缩进）要分成多行书写。   
长表达式要在低优先级操作符处分新行，操作符放在新行之首，
划分出的新行要进行适当的缩进，缩进长度以4个空格为单位。

举例：
```cpp
// 下面是一个处理的较为合理的例子
nCount = Fun1(nl, n2, n3)
    + (nNumberl * GetDate(n4, n5, n6)) * nNumber1;
```

#### 2.1.6 清晰划分控制语句的语句块
描述：
1. 控制语句 `if, for, while, do...while, switch` 的语句部分一定要用 `{` 和 `}` 括起来
    （即使只有一条语句）。
2. `{` 与控制语句同行或者，`{` 和 `}` 单独占一行，与控制语句的首字母应处在同一列上。
3. `}` 单独占一行。但在 `do...while` 结构中，`while` 前的 `}` 不能单独占一行，必须和 `while` 同行。

举例：
```cpp
// 不要像下面这样写代码
if (x == 0)
return;
else
while (x > min)
x--;

// 应该这样写
if (x == 0) {
    return;
} else {
    while (x > min) {
        x--;
    }
}
```

#### 2.1.7 一行只写一条语句或标号
规则描述：一行只写一条程序语句或标号（仅针对 `case`）。

举例：
```cpp
// 不要这样写
x = x0; y = y0;
while (IsOk(x)) {x++;}

// 应该这样写代码
x = x0;
y = y0;
while (IsOk(x))
{
    x++;
}
```

#### 2.1.8 一次只声明、定义一个变量
描述：一次（一条声明、定义语句）只声明、定义一个变量。

理由：提高代码的可读性，方便加入后置注释。

举例：
```cpp
// 不要这样写 
int width, length;

// 应该这样写
int width;
int length;
```


#### 2.1.9 在表达式中使用括号
描述：对于一个表达式，在一个二元、三元操作符操作的操作数的两边，应该放置 `(` 和 `)`，直到最高运算逻辑。

理由：避免出现不明确的运算、赋值顺序，提高代码的可读性。

举例：
```cpp
//下面这行代码
result = fact / 100 * number + rem;

//最好写成这样
result = ((fact / 100) * number) + rem;
```

----

### 2.2 注释
这一部分对程序注释提出了要求。

程序中的注释是程序与日后的程序读者之间通信的重要手段。
良好的注释能够帮助读者理解程序，为后续阶段进行测试和维护提供明确的指导。

下面是关于注释的基本原则：
1. 注释内容要清晰明了，含义准确，防止出现二义性。
2. 边写代码边注释，修改代码的同时修改相应的注释，保证代码与注释的一致性。

#### 2.2.1 对函数进行注释
级别：规则 

描述：
+ 在函数的声明之前，要给出精练的注释（不必牵扯太多的内部细节），让使用者能够快速获得足够的信息使用函数。
    格式不做具体要求。
+ 在函数的定义之前，要给出足够的注释。注释格式**不需要像这样：**
```cpp
    /***************************************************************
    【函数名称】         (必需)
    【函数功能】         (必需)
    【参数】             (必需。标明各参数是输入参数还是输出参数。) 
    【返回值】           (必需。解释返回值的意义。)
    【开发者及日期】      (必需)
    【更改记录】         (若有修改，则必需注明)
    ****************************************************************/
```

只要能让人看得懂就行了。


#### 2.2.2 对类进行注释
规范级别：规则

描述：在类的声明之前，要给出足够而精练的注释。注释格式不需要像这样：
```cpp
/***************************************************************
【类名】            (必需)
【功能】            (必需)
【接口说明】        (必需)
【开发者及日期】    (必需)
【更改记录】        (若修改过则必需注明)
****************************************************************/
```

#### 2.2.3 对文件进行注释
级别：规则 

描述：在头文件、实现文件的首部，一定要有文件注释，用来介绍文件内容。注释格式不需要像这样：
```cpp
/***************************************************************
【文件名】          (必需)
【功能模块和目的】  (必需)
【开发者及日期】    (必需)
【更改记录】        (若修改过则必需注明)
****************************************************************/
```

#### 2.2.4 对每个空循环体要给出确认性注释
描述：建议对每个空循环体给出确认性注释。

理由：提示自己和别人，这是空循环体，并不是忘了。 

举例：
```cpp
while (g_bOpen == 1)
{
    // 空循环
}
```


#### 2.2.5 对多个 `case` 共用一个出口的情况给出确认性注释
级别：建议

描述：建议对多个 `case` 语句共用一个出口的情况给出确认性注释。

理由：提示自己和别人，这几个 `case` 语句确实是共用一个出口，并不是遗漏了。 

举例：
```cpp
switch (nNumber)
{
    case 1:
        nCount++; 
        break; 
    case 2: 
    case 3: 
        nCount--;
        break; // 当 nNumber 等于 2 或 3 时，进行同样的处理
    default: 
        break;
}
```

#### 2.2.6 其它应该考虑进行注释的地方

除上面说到的，对于以下情况，也应该考虑进行注释：
+ 变量的声明、定义。通过注释，解释变量的意义、存取关系等；
    例如：
    
```cpp
   int m_iNumber; // 记录图形个数。被 `SetDate()`、`GetDate()` 使用。 
```


+ 数据结构的声明。通过注释，解释数据结构的意义、用途等；
    例如：
```cpp
    // 定义结构体，存储元件的端点。用于将新旧的端点对应。 
    typedef struct 
    {
        short int nBNN; 
        short int nENN; 
        short int nBNO; 
        short int nENO;
    } Element;
```

+ 分支。通过注释，解释不同分支的意义；
    例如：
    
```cpp
    if (m_iShortRadio == 0) // 三相的情况
    {
        strvC.Format("%-10.6f", vC); 
        straC.Format("%-10.6f", aC);
    }
    else if (m_iShortRadio == 1) // 两相的情况
    {
        strvC = _T("");
        straC = _T("");
    }
```

+ 调用函数。通过注释，解释调用该函数所要完成的功能； 
    例如：
    
```cpp
   SetDate(m_nNumber); // 设置当前的图形个数。 
```

+ 赋值。通过注释，说明赋值的意义；
    例如：
```cpp
    m_bDraw = 1; // 将当前设置为绘图状态 
```

+ 程序块的结束处。通过注释，标识程序块的结束。
    例如：
    
```cpp
    if (name == White)
    {
        ...
        if (age == 20)
            ...
        } // 年龄判断、处理结束
        ...
   } // 姓名判断、处理结束 
```


+ 其它有必要加以注释的地方 
  

#### 2.2.7 行末注释的对齐
描述：本项目不要求同一个函数或模块中的行末注释尽量对齐。当然，有时间就搞搞吧。

举例：
```cpp
nCount = 0;             // 计数器，表示正在处理第几个数据块
BOOL bNeedSave;         // 是否保存从服务器返回的数据
DWORD BytesWritten;     // 写入的数据长度
```

----

### 2.3 命名
对标识符和文件的命名要求。

#### 2.3.1 标识符命名要求
在程序中声明、定义的变量、常量、宏、类型、函数，在对其命名时应该遵守统一的命名规范。
具体要求如下：

+ 变量。
    变量名 = 作用域前缀 + 物理意义。  
    物理意义部分采用**驼峰命名法**。类名、函数和方法名、属性名和命名空间的标识符用**大驼峰**式书写格式，变量的标识符则用**小驼峰**式书写格式。**不推荐使用下划线**。
    
    详见：https://blog.csdn.net/jerry11112/article/details/84985026 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181213112746606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plcnJ5MTExMTI=,size_16,color_FFFFFF,t_70) 
    
    例：
    
    ```cpp
    class Game {
    private:
    	int PlayerNum;  // 玩家人数
    public:
    	Game(int playerNum);
        int GetPlayerNum();
    };
    
    Game::Game(int playerNum) : PlayerNum(playerNum) {};
    ```
    
    类Game，属性PlayerNum，方法GetPlayerNum用大驼峰；变量playerNum（传入Game构造函数的变量）用小驼峰。
    
    
    
    对于不同作用域的变量，其命名要求如表 2-1 所示；  

**表 2-1 作用域前缀**

| 变量种类       | 作用域前缀要求   | 示例                                  |
|:--------------|:---------------:|:------------------------------------:|
| 全局变量(注1)  | g_              | g_number <br/>全局整型变量          |
| 全局指针变量<br/>文件作用域变量   | gp_ | gp_number      |
| 局部变量       | （不添加作用域前缀）    | price       |
| 静态局部变量   | s_              | s_number                             |

> 注释：
>
>   1. 尽量避免使用全局变量！！！尽量使用局部变量，若实在无法避免，也要尽量用静态局部变量代替全局变量。

#### 2.3.2 其他命名要求


+ 常量  
    常量的名字要全部大写，包括至少一个英文单词。   
    常量指：`const` 修饰的量。如 `const int NUMBER = 100;`  
    枚举量。如 `enum Number{ONE，TWO, THREE};`

+ 宏  
    所有用宏形式定义的名字，包括宏常量和宏函数，名字要全部大写。可以用宏代替常量的功能。`#define INF 0x3f3f3f3f`

+ 类名、命名空间名
  
    **大驼峰**
    `class`、`struct`、`enum`、`union`、`typedef` 声明的类型、`namespace`。  
    
    **不建议在本项目中使用 `typedef`。**
    

例如：  
+ `typedef struct Student;`  
+ `class Card;` 
  
    函数名应以大写字母打头，由动词性英文单词或动宾型英文短语构成。  
    例如：`int GetPlayerNum(Game game); int Game::GetPlayerNum()`
    
+ 下面还有一些在命名时应该遵守的基本规范：

    + 不要使用以下划线打头的标识符。  
        例如：`_find` 是不允许出现的变量；
        
    + 尽量使用有意义的名字。应做到见其名知其意。  
        例如：`errorCode` 表示错误的代码；

#### 2.3.3 标识符长度要求
在程序中声明、定义的变量、常量、宏、类型、函数，它们的名字长度应当要在4至25个字符之内
对于某些已经被普遍认同 的简单命名，可不受本规则的限制。

如 for 循环的循环记数变量，可使用 `i`、`j`、`k` 命名。 
如名字过长，可使用缩写，缩写要使用大家一目了然的，家喻户晓的。例如： 
`Index` 可缩写为 `Idx`，`Button` 可缩写为 `Btn`，`Solution` 可缩写为 `Sln`。

temp 可缩写为 tmp;
increment 可缩写为 inc;
message 可缩写为 msg; 

#### 2.3.4 文件命名要求

代码文件的名字要与文件中声明、定义的重要重要函数名字或整体功能描述基本保持一致，
使功能与类文件名建立联系。
如 `math.h` 包括的都是和数学运算相关的函数声明。 

举例：
将类 `CMsgDialog` 的头文件和实现文件命名为 `msgdialog.h` 和 `msgdialog.cpp` 
就是一种比较简单、恰当的方法。

----

### 2.4 语句
对具体程序语句的使用要求。

#### 2.4.1 一条程序语句中只包含一个赋值操作符

在一条程序语句中，只应包含一个赋值操作符。赋值操作符包括：
`=, +=, -=, *=, /=, %=, >>=, <<=, &=, |=, !=, ^=, ++, --`

理由：避免产生不明确的赋值顺序。

举例：
```cpp
// 不要这样写 
b = c = 5; 
a = (b * c) + d++;

// 应该这样写 
c = 5; 
b = c;
a = (b * c) + d; 
d++;
```

#### 2.4.2 不要在控制语句的表达式中使用赋值操作符
不要在控制语句 `if, while, for` 和 `switch` 的条件表达式中使用赋值操作符。
赋值操作符包括： `=, +=, -=, *=, /=, %=, >>=, <<=, &=, |=, !=, ^=, ++, --`

理由：
已个类似于 `if (x = y)` 这样的写法是不明确、不清晰的，
代码的作者也许是想写成这样：`if (x == y)`。

举例：

```cpp
//不要像下面这样写代码： 
if (x -= dx)
{
    ...
}

//应该这样写: 
x -= dx; 
if (x)
{
    ...
}
```

#### 2.4.3 赋值表达式中的规定

在一个赋值表达式中：

+ 一个左值，在表达式中应该仅被赋值一次。
+ 对于多重赋值表达式，一个左值在表达式中仅应出现一次，不要重复出现。

理由：避免产生不明确的赋值顺序。

举例
```cpp
// 不要像下面这样写代码：
i = t[i++];     // 一个左值，在表达式中应该仅被赋值一次
a = b = c + a;  // 对于多重赋值表达式，一个左值在表达式中仅应出现一次，不能重复出现。
i = t[i] = 15;  // 对于多重赋值表达式，一个左值在表达式中仅应出现一次，不能重复出现。
```

#### 2.4.4 禁用 Goto 语句
程序中不要使 `goto` 语句。

理由：
这条规则的目的是为了确保程序的结构化，因为滥goto语句会使程序流程无规则，可读性差。

#### 2.4.5 避免对浮点数值类型做精确比较
不要对浮点类型的数据做等于、不等于这些精确的比较判断，要用范围比较代替精确比较。

理由：
由于存在舍入的问题，计算枧内部不能精确的表示所有的十进制浮点数，
用等于、不等于这种精确的比较方法就可能得出与预期相反的结果。
所以应该用大于、小于eps比较的方法代替精确比较的方法。

举例
```cpp
// 不要像下面这样写代码：
float number;
...
if (number == 0) // 精确比较
```

#### 2.4.6 对 `switch` 语句中每个分支结尾的要求
`switch` 语句中的每一个 `case` 分支，都要以 `break` 作为分支的结尾
（几个连续的空 `case` 语句允许共一个）

理由：使代码更容易理解；减少代码发生错误的可能性。

#### 2.4.7 `switch` 语句中的 `default` 分支
在 `switch` 语句块中，一定要有 `default` 分支来处理其它情况。
仅在 `switch` 中所有 `case` 已经包含了被判定表达式全部取值范围时候，可以不受本规则限制。

理由：用来处理 `switch` 语句中默认、特殊的情况。

#### 2.4.8 对指针的初始化
在定义指针变量的同时，对其进行初始化。如果定义时还不能为指针变量赋予有效值，则使其指向 `NULL`。

理由：减少使用未初始化指针变量的几率。

举例
```cpp
// 不要这样写代码
int* y;
y = &x;

// 应该这样写
int* y = &x;
```

#### 2.4.9 释放内存后的指针变量
当指针变量所指的内存被释放后，应该赋予指针一个合理的值。
除非该指针变量本身将要消失这种情况下不必赋值，否则应赋予 `NULL`。

理由：保证指针变量在其生命周期的全过程都指向一个合理的值。

#### 2.4.10 `new` 和 `delete`
局部的 `new` 和 `delete` 要成对出现；
`new` 要与 `delete` 对应，`new[]` 要与 `delete[]` 对应。

理由：防止内存泄露。

----

### 2.5 函数
对函数的要求。

#### 2.5.1 明确函数功能
函数体代码长度不应该超过 100 行（不包括注释）。

理由：明确函数功能（一个函数仅完成一件事情），精确（而不是近似）地实现函数设计。

#### 2.5.2 将重复使用的代码编写成函数
将重复使用的简单操作编写成函数。

理由：对于重复使用的功能，虽然很简单，也应以函数的形式来处理，这样可以简化代码，使代码更易于维护。

#### 2.5.3 函数声明和定义的格式要求
在声明和定义函数时，在函数参数列表中为各参数指定类型和名称。

理由：提高代码的可读性，改善可移植性。

举例
```cpp
// 不要象下面这样写代码：
f(int, char*);      // 函数声明
...
f(int a, char* b)   // 函数定义
{
    ...
}

// 应该这样写：
f(int a, char* b);  // 函数声明
...
f(int a, char* b)   // 函数定义
{
    ...
}
```

#### 2.5.4 为函数指定返回值
要为每一个函数指定它的返回值。如果函数没有返回值，则要定义返回类型为 `void`

理由：提高代码的可读性；改善代码的可移植性。

#### 2.5.5 在函数调用语句中不要使用赋值操作符
函数调用语句中，在函数的参数列表中不要使赋值操作符。
赋值操作符包括: `=, +=, -=, *=, /=, %=, >>=, <<=, &=, |=, !=, ^=, ++, --`

理由：避免产生不明确的赋值顺序。

举例
```cpp
//不要象下面这样写代码：
void fun1(int a);
void fun2(int b)
{
    fun1(++b); // 注意这里！
}

```

----

### 2.6 程序组织
对程序组织的要求。Visual Studio会帮我们完成程序组织。

#### 2.6.1 一个头文件中只声明一个函数、一类函数或一个类
在一个头文件中，只应该包含对一个函数的声明或一类函数的声明，使类时则只包含一个类的声明。
当头文件中包含一类函数时，这些函数功能必须可以抽象为一个共同的单词或短语。
头文件是指以 `.h` 为后缀的文件

理由：提高代码的可读性和文件级别重的可能性。

#### 2.6.2 一个源文件中只实现一个函数、一类函数或一个类
在一个源文件中，只应该包含对一个函数的定义或一类函数的定义，使类时则只包含一个类的定义。
当源文件中包含一类函数时，这些函数功能必须可以抽象为一个共同的单词或短语。
源文件指以 `.c` 为后缀的代码文件。

理由：提高代码的可读性和文件级别重的可能性。


#### 2.6.3 头文件中只包含声明，不应包含定义
在头文件中只包含声明，不要包含全局变量和函数的定义。
但宏和 `const` 要分情况讨论，不一定受本规则限制。

理由：在头文件中只应该包含各种声明，而不应该包含具体的实现。

#### 2.6.4 源文件中不要有函数的声明
在源文件中只应该包含对全局变量、文件作域变量、和函数的定义，不应该包含任何声明。
声明应该统一放到头文件中去。但宏和 `const` 要分情况讨论，不一定受本规则限

理由：内外有别，限制细节知悉范围，提高代码的可读性和可靠性。

#### 2.6.5 可被包含的文件
只允许头文件被包含到其它的代码文件中去。

理由：改善程序代码的组织结构。

#### 2.6.6 避免头文件的重复包含

所有的头文件的第一行必须是`#pragma once`，或其等价语句。

理由：详见百度”头文件的重复包含“。

----

### 2.7 全局变量
对公共变量（全局变量）的要求。

#### 2.7.1 严格限制全局变量的使用
在程序中要尽可能少的使公共变量。
在决定使用一个公共变量时，要仔细考虑，权衡得失。

理由：公共变量会增大模块间的耦合，甚至扩大错误传播范围。

#### 2.7.2 明确全局变量的定义
当你真的决定使用公共变量时，要仔细定义并明确公共变量的含义、作用、取值范围、与其它变量间的关系。
明确公共变量与操作此公共变量的函数之间的关系，如访问、修改和创建等。

#### 2.7.3 防止全局变量与局部变量重名
防止全局变量与局部变量重名。

----

### 2.8 类
对类的要求。

#### 2.8.1 关于默认构造函数
为每一个类显示定义默认构造函数。

理由：确保类的编写者考虑在类对象初始化时，可能出现的各种情况。

举例
```cpp
class CMyClass
{
    CMyClass();
    ...
};
```

#### 2.8.2 关于拷贝构造函数
当类中包含指针类型的数据成员时，必须显式地定义拷贝构造函数。
建议为每个类都显示定义拷贝构造函数。

理由：确保类的编写者考虑类对象在被拷贝时可能出现的各种情况。

举例，
```cpp
class CMyClass
{
    CMyClass(CMyClass& object);
    ...
};
```

#### 2.8.3 为类重载 `=` 操作符
当类中包含指针类型的数据成员时，必须显示重载 `=` 操作符。
建议为每个类都显示重载 `=` 操作符。

理由：确保类的编写者考虑将一个该类对象赋值给另一个该类的对象时，可能出现的各种情况。

举例：
```cpp
//应该这样写代码
class CMyClass
{
    ...
    operator = (const CMyClass& object);
    ...
};
```

#### 2.8.4 关于析构函数
为每一个类显示的定义析构函数。

理由：确保类的编写者考虑类对象在析构时，可能出现的各种情况。

举例
```cpp
class CMyClass
{
    ...
    ~CMyClass();
    ...
};
```

#### 2.8.5 虚拟析构函数
该规则参考自《Effective C++》中的条款14。（C++ 虚拟析构函数有什么用？https://www.zhihu.com/question/54540305）

基类的析构函数要为虚拟函数（virtual Destructor)

理由：保证类对象内存被释放之前，基类和派生类的析构函数都被调用。

#### 2.8.6 类数据成员的访问控制
类对外的接囗应该是完全功能化的，类中可以定义 `public` 的成员函数，但不应该有 `public` 的数据成员。

理由：
要想改变对象的当前状态，应该通过它的成员函数来实现，而不应该通过直接设置它的数据成员这种方法。
一个类的数据成员应该声明为 `private` 的，最起码也应该是 `protected` 的。

#### 2.8.7 不使用多继承
C++ 提供多继承的枳制。
但我们在使用多继承的时，一定要慎重，在决定使用多继承时，确实要有非常充分的理由。

事实上，多继承在本工程中完全可以避免。

理由：
多继承会显著增加代码的复杂性，还会带来潜在的混淆。
比如在很多 C++ 书籍中提到的菱形继承问题。

#### 2.8.8 考虑类的复用
类设计的同时，考虑类的可复用性。

----

### 2.9 其它
下面这几条要求，不适合合并到上面任何一类，所以单独作为一部分。

#### 2.9.1 使用 string，而非 C 风格字符串
```cpp
string str;  // OK
char str[];  // Never use it!
```




## 3 并不会结束
以上就是我们目前要求 C++ 程序遵守的规范的全部内容。欢迎大家讨论、补充和修订。

